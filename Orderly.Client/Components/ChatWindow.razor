
@using Orderly.Client.Services
@using Orderly.Shared.Dtos
@using Orderly.Shared.Helpers

@implements IDisposable

@namespace Orderly.Client.Components

<style>
    .chat-container {
        display: flex;
        height: 100%;
        overflow: hidden;
    }

    .chat-wrapper {
        position: relative;
        background-color: var(--bg);
        color: var(--fg);
        display: flex;
        flex-direction: column;
        height: 100%;
        border: 1px solid var(--border);
    }

    .back-button {
        position: absolute;
        top: 12px;
        left: 12px;
        z-index: 10;
        width: 40px;
        height: 40px;
        background-color: var(--nav-bg);
        color: var(--fg);
        border: none;
        border-radius: 50%;
        box-shadow: 0 2px 8px rgba(0,0,0,0.25);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background-color 0.2s ease, color 0.2s ease;
    }

    .back-button:hover,
    .back-button:focus {
        background-color: var(--primary);
        color: white;
        outline: none;
    }

    .back-button i {
        font-size: 1.25rem;
        pointer-events: none;
    }

    .chat-body {
        flex-grow: 1;
        overflow-y: auto;
        padding: 4rem 1rem 1rem 1rem;
        background-color: var(--bg);
    }

    .chat-input {
        padding: 1rem;
        background-color: var(--nav-bg);
        border-top: 2px solid var(--border);
    }

    .input-area {
        display: flex;
        gap: 0.5rem;
        align-items: center;
    }

    .chat-textarea {
        flex-grow: 1;
        background-color: var(--bg);
        border: 1px solid var(--border);
        color: var(--fg);
        border-radius: 12px;
        padding: 0.75rem 1rem;
        font-size: 0.95rem;
        resize: none;
        overflow: hidden;
        min-height: 40px;
        max-height: 200px;
        box-shadow: none !important;
        outline: none;
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
    }

    .chat-textarea:focus {
        background-color: var(--bg);
        color: var(--fg);
        border-color: var(--primary);
        box-shadow: none !important;
        outline: none !important;
    }

    .send-button {
        background-color: var(--primary);
        color: #fff;
        border: none;
        border-radius: 10px;
        padding: 0.65rem 1.25rem;
        transition: background-color 0.2s ease;
    }

    .send-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .send-button:hover:not(:disabled) {
        background-color: #2563eb;
    }

    .chat-bubble {
        display: inline-block;
        max-width: 75%;
        word-wrap: break-word;
        padding: 0.75rem 1rem;
        font-size: 0.95rem;
        line-height: 1.5;
        border-radius: 16px;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
        margin-bottom: 0.25rem;
        opacity: 0;
        transform: translateY(8px);
        animation: fade-in-up 0.3s ease-out forwards;
    }

    @@keyframes fade-in-up {
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .chat-bubble.from-me {
        background-color: var(--primary);
        color: white;
        border-bottom-right-radius: 0;
        align-self: flex-end;
    }

    .chat-bubble.from-them {
        background-color: var(--border);
        color: var(--fg);
        border-bottom-left-radius: 0;
        align-self: flex-start;
    }

    .chat-username {
        font-size: 0.75rem;
        font-weight: 600;
        opacity: 0.8;
        margin-bottom: 0.25rem;
        user-select: none;
    }

    .chat-timestamp {
        font-size: 0.7rem;
        opacity: 0.6;
        margin-top: 0.25rem;
        text-align: right;
        user-select: none;
    }

    .chat-sidebar {
        width: 300px;
        background-color: var(--nav-bg);
        display: flex;
        flex-direction: column;
        gap: 1rem;
        font-size: 0.95rem;
        color: var(--fg);
        border-left: 2px solid var(--border);
        background-color: var(--nav-bg);
        padding: 1rem;
        overflow-y: auto;
        max-height: 100%;
    }

    .chat-sidebar h5 {
        font-size: 1.1rem;
        font-weight: 600;
        margin-bottom: 0.75rem;
        border-bottom: 1px solid var(--border);
        padding-bottom: 0.5rem;
    }

    .chat-sidebar .sidebar-section {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }

    .chat-sidebar .sidebar-label {
        font-weight: 500;
        color: var(--text-secondary, #6c757d);
        font-size: 0.85rem;
    }

    .chat-sidebar .sidebar-value {
        font-weight: 500;
        color: var(--fg);
        word-break: break-word;
    }

    .chat-sidebar .public-id {
        color: var(--primary);
        font-weight: 600;
    }
</style>

@if (CurrentUser is null || CurrentChat is null)
{
    <div class="text-muted p-4">Loading chat...</div>
}
else
{
    <div class="chat-container d-flex h-100">
        <div class="chat-wrapper flex-grow-1 d-flex flex-column">
            @*
                Back Button
            *@

            <button class="back-button" @onclick="OnBackClicked" aria-label="Go back">
                <i class="bi bi-arrow-left"></i>
            </button>

            @*
                Chat Body
            *@

            <div class="chat-body" @ref="ChatBodyRef">
                @if (Messages is null || !Messages.Any())
                {
                    <div class="text-center mt-4 user-select-none">
                        No messages yet
                    </div>
                }
                else
                {
                    UserDto lastSender = null;
                    foreach (var msg in Messages)
                    {
                        bool isMine = msg.Sender.PublicId == CurrentUser.PublicId;
                        bool showName = lastSender == null || lastSender.PublicId != msg.Sender.PublicId;
                        lastSender = msg.Sender;

                        <div class="chat-message-container mb-2 @(isMine ? "text-end" : "text-start")">
                            @if (showName)
                            {
                                <div class="chat-username small fw-semibold mb-1 @(isMine ? "text-primary" : "text-secondary")">
                                    @(isMine ? "You" : msg.Sender.FullName)
                                </div>
                            }

                            <div class="chat-bubble @(isMine ? "from-me" : "from-them")">
                                <div class="chat-message-text">@msg.Content</div>
                                <div class="chat-timestamp small mt-1">
                                    @DateTimeHelper.ToShortTimeAgo(msg.CreatedAt)
                                </div>
                            </div>
                        </div>
                    }
                }
            </div>

            @*
                Chat Input
            *@

            <div class="chat-input px-4 py-3">
                <div class="input-group">
                    <textarea class="form-control chat-textarea"
                              placeholder=@(CanSendMessages ? "Type your message..." : "You can't send messages to this chat.")
                              rows="1"
                              maxlength="2000"
                              readonly="@(!CanSendMessages)"
                              @bind="@NewMessageContent"
                              @ref="TypeAreaRef"
                              @oninput="@OnTypeAreaInput">
                    </textarea>
                    <button class="btn btn-primary send-button px-4"
                            @onclick="OnSendClicked"
                            disabled="@(!IsMessageSendable())">
                        <i class="bi bi-send-fill"></i>
                    </button>
                </div>
            </div>
        </div>

        @*
            Sidebar
        *@

        @if (SidebarContent is not null)
        {
            <div class="chat-sidebar p-3" style="width: 300px;">
                @SidebarContent
            </div>
        }
    </div>
}

<script>
    window.scrollToBottom = (container) => {
        if (container) {
            container.scrollTop = container.scrollHeight;
        }
    };

    window.resizeTextarea = (textarea) => {
        textarea.style.height = 'auto';
        textarea.style.height = (textarea.scrollHeight) + 'px';
    };

    window.getScrollHeight = (el) => el.scrollHeight;

    window.scrollToOffsetFromBottom = (el, previousScrollHeight) => {
        const newScrollHeight = el.scrollHeight;
        const scrollDifference = newScrollHeight - previousScrollHeight;
        el.scrollTop = scrollDifference;
    };

    window.attachChatScrollToTopListener = (element, dotNetHelper) => {
        if (!element) return;

        element.addEventListener('scroll', () => {
            if (element.scrollTop < 20) {
                dotNetHelper.invokeMethodAsync('OnScrolledToTop');
            }
        });
    };
</script>

@code {
    [Parameter]
    public bool CanSendMessages { get; set; } = false;

    [Parameter]
    public UserDto? CurrentUser { get; set; }

    [Parameter]
    public ChatThreadDto? CurrentChat { get; set; }

    [Parameter]
    public List<ChatMessageDto>? Messages { get; set; }

    [Parameter]
    public EventCallback<string> OnSend { get; set; }

    [Parameter]
    public RenderFragment? SidebarContent { get; set; }

    private string NewMessageContent = string.Empty;

    private CancellationTokenSource Cts = new();

    private PeriodicTimer MessageTimeUpdateTimer;

    private ElementReference ChatBodyRef;

    private ElementReference TypeAreaRef;

    private DotNetObjectReference<ChatWindow>? DotNetRef;

    private bool HasMoreMessages = true;

    private bool IsLoadingOlderMessages = false;

    private bool IsLoading = false;

    protected override void OnInitialized()
    {
        StartMessageTimeUpdater();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Attach chat scroll to top listener event

        if (firstRender)
        {
            DotNetRef = DotNetObjectReference.Create(this);

            await JS.InvokeVoidAsync("attachChatScrollToTopListener", ChatBodyRef, DotNetRef);
        }

        // Scroll to the bottom of the message list

        if (Messages?.Any() is true)
        {
            await JS.InvokeVoidAsync("scrollToBottom", ChatBodyRef);
        }
    }

    private void StartMessageTimeUpdater()
    {
        // Poll every 30 seconds

        MessageTimeUpdateTimer = new PeriodicTimer(TimeSpan.FromSeconds(30));

        _ = Task.Run(async () =>
        {
            while (await MessageTimeUpdateTimer.WaitForNextTickAsync(Cts.Token))
            {
                // Force the UI to reload data, causing messages to refresh
                // their display time

                await InvokeAsync(StateHasChanged);
            }
        });
    }

    private async Task OnBackClicked()
    {
        await JS.InvokeVoidAsync("history.back");
    }

    private async Task OnTypeAreaInput(ChangeEventArgs e)
    {
        await JS.InvokeVoidAsync("resizeTextarea", TypeAreaRef);
    }

    private async Task OnSendClicked()
    {
        // The message must be sendable

        if (!IsMessageSendable())
        {
            return;
        }

        // Send event

        await OnSend.InvokeAsync(NewMessageContent);

        NewMessageContent = string.Empty;

        // Let UI update

        await Task.Yield();

        // Scroll to the bottom to see the new message

        await JS.InvokeVoidAsync("scrollToBottom", ChatBodyRef);

        // Reset type area size

        await JS.InvokeVoidAsync("resizeTextarea", TypeAreaRef);
    }

    [JSInvokable]
    public async Task OnScrolledToTop()
    {
        if (IsLoadingOlderMessages || !HasMoreMessages || CurrentChat is null || Messages is null)
        {
            return;
        }

        // Get the start message (this is the earliest message currently
        // loaded and will be used as the starting point for loading older
        // messages)

        ChatMessageDto? startMessage = Messages?.FirstOrDefault();

        if (startMessage is null)
        {
            return;
        }

        // Load older messages

        IsLoadingOlderMessages = true;

        List<ChatMessageDto>? olderMessages = await _ChatService.GetChatMessagesAsync(CurrentChat, startMessage.PublicId);

        if (olderMessages is not null && olderMessages.Any())
        {
            // Save the current scroll height

            var previousScrollHeight = await JS.InvokeAsync<int>("getScrollHeight", ChatBodyRef);

            // Insert older messages at the front of the list

            Messages?.InsertRange(0, olderMessages);

            StateHasChanged();

            // Wait for UI

            await Task.Yield();

            // Restore scroll so it doesn't jump

            await JS.InvokeVoidAsync("scrollToOffsetFromBottom", ChatBodyRef, previousScrollHeight);
        }
        else
        {
            // No more messages to load

            HasMoreMessages = false;
        }

        IsLoadingOlderMessages = false;
    }

    private bool IsMessageSendable()
    {
        if (!CanSendMessages)
        {
            return false;
        }

        if (string.IsNullOrWhiteSpace(NewMessageContent))
        {
            return false;
        }

        string trimmed = NewMessageContent.Trim();

        // Disallow messages with only new lines or just whitespace

        if (trimmed.Replace("\n", "").Replace("\r", "").Length == 0)
        {
            return false;
        }

        // Disallow messages that are too long

        if (trimmed.Length > 2000)
        {
            return false;
        }

        return true;
    }

    public void Dispose()
    {
        Cts.Cancel();
        Cts.Dispose();

        DotNetRef?.Dispose();
    }

    [Inject]
    private IJSRuntime JS { get; set; }

    [Inject]
    private ChatService _ChatService { get; set; }
}
